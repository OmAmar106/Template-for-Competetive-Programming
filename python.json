{
    "gcd": {
		"prefix": "gcd",
		"body": [
			"def gcd(a,b):",
			"\tif a%b==0:",
			"\t\treturn b",
			"\telse:",
			"\t\treturn gcd(b,a%b)",
			"def lcm(a,b):",
            "\treturn (a*b)//gcd(a,b)",
	    ],  
		"description": "gcd and lcm"
	},
    "SortedList": {
        "prefix": "bsortl",
        "body": [
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "from bisect import bisect_right,bisect_left",
            "T = TypeVar('T')",
            "class SortedList(Generic[T]):",
            "\tBUCKET_RATIO = 16",
            "\tSPLIT_RATIO = 24",
            "\tdef __init__(self, a: Iterable[T] = []) -> None:",
            "\t\ta = list(a)",
            "\t\tn = self.size = len(a)",
            "\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
            "\t\t\ta.sort()",
            "\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "\tdef __iter__(self) -> Iterator[T]:",
            "\t\tfor i in self.a:",
            "\t\t\tfor j in i: yield j",
            "\tdef __reversed__(self) -> Iterator[T]:",
            "\t\tfor i in reversed(self.a):",
            "\t\t\tfor j in reversed(i): yield j",
            "\tdef __eq__(self, other) -> bool:",
            "\t\treturn list(self) == list(other)",
            "\tdef __len__(self) -> int:",
            "\t\treturn self.size",
            "\tdef __repr__(self) -> str:",
            "\t\treturn \"SortedMultiset\" + str(self.a)",
            "\tdef __str__(self) -> str:",
            "\t\ts = str(list(self))",
            "\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
            "\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
            "\t\tfor i, a in enumerate(self.a):",
            "\t\t\tif x <= a[-1]: break",
            "\t\treturn (a, i, bisect_left(a, x))",
            "\tdef __contains__(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, _, i = self._position(x)",
            "\t\treturn i != len(a) and a[i] == x",
            "\tdef count(self, x: T) -> int:",
            "\t\treturn self.index_right(x) - self.index(x)",
            "\tdef insert(self, x: T) -> None:",
            "\t\tif self.size == 0:",
            "\t\t\tself.a = [[x]]",
            "\t\t\tself.size = 1",
            "\t\t\treturn",
            "\t\ta, b, i = self._position(x)",
            "\t\ta.insert(i, x)",
            "\t\tself.size += 1",
            "\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
            "\t\t\tmid = len(a) >> 1",
            "\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
            "\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
            "\t\tans = a.pop(i)",
            "\t\tself.size -= 1",
            "\t\tif not a: del self.a[b]",
            "\t\treturn ans",
            "\tdef remove(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, b, i = self._position(x)",
            "\t\tif i == len(a) or a[i] != x: return False",
            "\t\tself._pop(a, b, i)",
            "\t\treturn True",
            "\tdef lt(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] < x:",
            "\t\t\t\treturn a[bisect_left(a, x) - 1]",
            "\tdef le(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] <= x:",
            "\t\t\t\treturn a[bisect_right(a, x) - 1]",
            "\tdef gt(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn a[bisect_right(a, x)]",
            "\tdef ge(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn a[bisect_left(a, x)]",
            "\tdef __getitem__(self, i: int) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor a in reversed(self.a):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return a[i]",
            "\t\telse:",
            "\t\t\tfor a in self.a:",
            "\t\t\t\tif i < len(a): return a[i]",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef pop(self, i: int = -1) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor b, a in enumerate(reversed(self.a)):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
            "\t\telse:",
            "\t\t\tfor b, a in enumerate(self.a):",
            "\t\t\t\tif i < len(a): return self._pop(a, b, i)",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef index(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn ans + bisect_left(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef index_right(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn ans + bisect_right(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef find_closest(self, k: T) -> Optional[T]:",
            "\t\tif self.size == 0:",
            "\t\t\treturn None",
            "\t\tltk = self.le(k)",
            "\t\tgtk = self.ge(k)",
            "\t\tif ltk is None:",
            "\t\t\treturn gtk",
            "\t\tif gtk is None:",
            "\t\t\treturn ltk",
            "\t\tif abs(k-ltk)<=abs(k-gtk):",
            "\t\t\treturn ltk",
            "\t\telse:",
            "\t\t\treturn gtk"
        ],
        "description": "SortedList using buckets"
    },    
    "SegmentTree": {
        "prefix": "SegmentTree",
        "body": [
            "class SegmentTree:",
            "\tdef __init__(self, arr):",
            "\t\tself.arr = arr",
            "\t\tself.n = len(arr)",
            "\t\tself.tree = [0] * (4 * self.n)",
            "\t\tself.lazy = [0] * (4 * self.n)",
            "\t\tself.build_tree(1, 0, self.n - 1)",
            "\tdef build_tree(self, node, start, end):",
            "\t\tif start == end:",
            "\t\t\tself.tree[node] = self.arr[start]",
            "\t\telse:",
            "\t\t\tmid = (start + end) // 2",
            "\t\t\tself.build_tree(2 * node, start, mid)",
            "\t\t\tself.build_tree(2 * node + 1, mid + 1, end)",
            "\t\t\tself.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef propagate_lazy(self, node, start, end):",
            "\t\tif self.lazy[node] != 0:",
            "\t\t\tself.tree[node] += self.lazy[node]",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += self.lazy[node]",
            "\t\t\t\tself.lazy[2 * node + 1] += self.lazy[node]",
            "\t\t\tself.lazy[node] = 0",
            "\tdef update(self, node, start, end, l, r, value):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn",
            "\t\tif start >= l and end <= r:",
            "\t\t\tself.tree[node] += value",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += value",
            "\t\t\t\tself.lazy[2 * node + 1] += value",
            "\t\t\treturn",
            "\t\tmid = (start + end) // 2",
            "\t\tself.update(2 * node, start, mid, l, r, value)",
            "\t\tself.update(2 * node + 1, mid + 1, end, l, r, value)",
            "\t\tself.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef range_update(self, l, r, value):",
            "\t\tself.update(1, 0, self.n - 1, l, r, value)",
            "\tdef query(self, node, start, end, l, r):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn float('inf')",
            "\t\tif start >= l and end <= r:",
            "\t\t\treturn self.tree[node]",
            "\t\tmid = (start + end) // 2",
            "\t\treturn min(self.query(2 * node, start, mid, l, r),",
            "\t\t           self.query(2 * node + 1, mid + 1, end, l, r))",
            "\tdef range_query(self, l, r):",
            "\t\treturn self.query(1, 0, self.n - 1, l, r)",
            "\tdef to_list(self):",
            "\t\tresult = []",
            "\t\tfor i in range(self.n):",
            "\t\t\tresult.append(self.range_query(i, i))",
            "\t\treturn result",
        ],
        "description": "Segment Tree implementation with lazy propagation"
    },
	"h": {
		"prefix": "h",
		"body": [
			"import random",
			"RANDOM = random.randrange(2**62)",
			"def w(x):",
			"\treturn x ^ RANDOM",
		],
		"description": "hashing , Use whenever using dictionary,to avoid tle"
	},
	"sortl": {
        "prefix": "fsortl",
        "body": [
			"from bisect import bisect_right, bisect_left",
            "class FenwickTree:",
            "\tdef __init__(self, x):",
            "\t\tbit = self.bit = list(x)",
            "\t\tsize = self.size = len(bit)",
            "\t\tfor i in range(size):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < size:",
            "\t\t\t\tbit[j] += bit[i]",
            "\tdef update(self, idx, x):",
            "\t\twhile idx < self.size:",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef __call__(self, end):",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1 ",
            "\t\treturn x",
            "\tdef find_kth(self, k):",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(self.size.bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < self.size and self.bit[right_idx] <= k:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1, k",
            "class SortedList:",
            "\tblock_size = 700",
            "\tdef __init__(self, iterable=()):",
            "\t\tself.macro = []",
            "\t\tself.micros = [[]]",
            "\t\tself.micro_size = [0]",
            "\t\tself.fenwick = FenwickTree([0])",
            "\t\tself.size = 0",
            "\t\tfor item in iterable:",
            "\t\t\tself.insert(item)",
            "\tdef insert(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\tj = bisect_right(self.micros[i], x)",
            "\t\tself.micros[i].insert(j, x)",
            "\t\tself.size += 1",
            "\t\tself.micro_size[i] += 1",
            "\t\tself.fenwick.update(i, 1)",
            "\t\tif len(self.micros[i]) >= self.block_size:",
            "\t\t\tself.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]",
            "\t\t\tself.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1",
            "\t\t\tself.fenwick = FenwickTree(self.micro_size)",
            "\t\t\tself.macro.insert(i, self.micros[i + 1][0])",
            "\tdef add(self, x):",
            "\t\tself.insert(x)",
            "\tdef pop(self, k=-1):",
            "\t\ti, j = self._find_kth(k)",
            "\t\tself.size -= 1",
            "\t\tself.micro_size[i] -= 1",
            "\t\tself.fenwick.update(i, -1)",
            "\t\treturn self.micros[i].pop(j)",
            "\tdef remove(self, N: int):",
            "\t\tidx = self.bisect_left(N)",
            "\t\tself.pop(idx)",
            "\tdef __getitem__(self, k):",
            "\t\ti, j = self._find_kth(k)",
            "\t\treturn self.micros[i][j]",
            "\tdef count(self, x):",
            "\t\treturn self.bisect_right(x) - self.bisect_left(x)",
            "\tdef __contains__(self, x):",
            "\t\treturn self.count(x) > 0",
            "\tdef bisect_left(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_left(self.micros[i], x)",
            "\tdef bisect_right(self, x):",
            "\t\ti = bisect_right(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_right(self.micros[i], x)",
            "\tdef _find_kth(self, k):",
            "\t\treturn self.fenwick.find_kth(k + self.size if k < 0 else k)",
            "\tdef __len__(self):",
            "\t\treturn self.size",
            "\tdef __iter__(self):",
            "\t\treturn (x for micro in self.micros for x in micro)",
            "\tdef __repr__(self):",
            "\t\treturn str(list(self))"
        ],
        "description": "sorted list using fenwick tree use for insertion,deletion,traversel in log(n)"
    },
    "bootstrap": {
        "prefix": "bootstrap",
        "body": [
            "from types import GeneratorType",
            "",
            "def bootstrap(f, stack=[]):",
            "\tdef wrappedfunc(*args, **kwargs):",
            "\t\tif stack:",
            "\t\t\treturn f(*args, **kwargs)",
            "\t\telse:",
            "\t\t\tto = f(*args, **kwargs)",
            "\t\t\twhile True:",
            "\t\t\t\tif type(to) is GeneratorType:",
            "\t\t\t\t\tstack.append(to)",
            "\t\t\t\t\tto = next(to)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.pop()",
            "\t\t\t\t\tif not stack:",
            "\t\t\t\t\t\tbreak",
            "\t\t\t\t\tto = stack[-1].send(to)",
            "\t\t\treturn to",
            "\treturn wrappedfunc",
            "",
            "# @bootstrap",
            "# put this just on top of recursion function to increase the recursion limit",
            "",
            "# rather than return now use yield and when function being called inside itself, use yield before the function name",
            "# example usage:",
            "# @bootstrap",
            "# def rec1(L,k,cur,count):",
            "# \tif count>=100000:",
            "# \t\tyield float('INF')",
            "# \tif cur+k+1>=len(L)-1:",
            "# \t\tyield L[cur]+2",
            "# \tif cur in d:",
            "# \t\tyield d[cur]",
            "# \tans = float('INF')",
            "# \tmini = float('INF')",
            "# \tfor i in range(k+1,0,-1):",
            "# \t\tif L[cur+i]<mini:",
            "# \t\t\tans = min(ans,1+L[cur]+(yield rec1(L,k,cur+i,count+1)))",
            "# \t\t\tmini = L[cur+i]",
            "# \td[cur] = ans",
            "# \tyield ans",
            "# the limit of recursion on cf is 10**6"
        ],
        "description": "Decorator to increase recursion limit using the bootstrap method with yield."
    }
}
