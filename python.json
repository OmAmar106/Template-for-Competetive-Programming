{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cp": {
		"prefix": "cp",
		"body": [
			"import sys,math,random",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations",
            "",
            "# functions #",
            "MOD = 998244353",
            "MOD = 10**9 + 7",
			"RANDOM = random.randrange(2**62)",
            "def gcd(a,b):",
			"\tif a%b==0:",
			"\t\treturn b",
			"\telse:",
			"\t\treturn gcd(b,a%b)",
			"def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
			"def w(x):",
			"\treturn x ^ RANDOM",
            "##",
            "",
            "#String hashing : sh/shclass, fenwick sortedlist : fsortl, Number : numtheory, SparseTable : SparseTable",
            "#bucket sorted list : bsortl, segment tree(lazy propogation) : SegmentTree,Other, bootstrap : bootstrap",
            "#binary indexed tree : BIT, segment tree(point updates) : SegmentPoint, Convex Hull : hull", 
            "#Combinatorics : pnc, Diophantine Equations : dpheq, Graphs : graphs, DSU : DSU, Geometry: Geometry",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "",
			"def solve():",
			"\tn = int(sys.stdin.readline().strip())",
			"\tL = list(map(int, sys.stdin.readline().split()))",
			"\t#L1 = list(map(int, sys.stdin.readline().split()))",
			"\t#st = sys.stdin.readline().strip()",
			"for _ in range(int(sys.stdin.readline().strip())):",
			"\tsolve()"
	    ],  
		"description": "codeforces template"
	},
    "tcp": {
		"prefix": "tcp",
		"body": [
			"import sys,math,random",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations",
            "",
            "# functions #",
            "MOD = 998244353",
            "MOD = 10**9 + 7",
			"RANDOM = random.randrange(2**62)",
            "def gcd(a,b):",
			"\tif a%b==0:",
			"\t\treturn b",
			"\telse:",
			"\t\treturn gcd(b,a%b)",
			"def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
			"def w(x):",
			"\treturn x ^ RANDOM",
            "##",
            "",
            "#String hashing : sh/shclass, fenwick sortedlist : fsortl, Number : numtheory, SparseTable : SparseTable",
            "#bucket sorted list : bsortl, segment tree(lazy propogation) : SegmentTree,Other, bootstrap : bootstrap",
            "#binary indexed tree : BIT, segment tree(point updates) : SegmentPoint, Convex Hull : hull", 
            "#Combinatorics : pnc, Diophantine Equations : dpheq, Graphs : graphs, DSU : DSU, Geometry: Geometry",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "",
			"def solve():",
			"\tn = int(sys.stdin.readline().strip())",
			"\tL = list(map(int, sys.stdin.readline().split()))",
			"\t#L1 = list(map(int, sys.stdin.readline().split()))",
			"\t#st = sys.stdin.readline().strip()",
			"solve()"
	    ],  
		"description": "atcoder/cses template"
	},
    "hull": {
		"prefix": "hull",
		"body": [
			"def convex_hull_trick(m, c, integer=True):",
			"\t\"\"\"",
			"\tGiven lines on the form y = m[i] * x + c[i] this function returns intervals,",
			"\tsuch that on each interval the convex hull is made up of a single line.",
			"\tInput:",
			"\t\tm: list of the slopes",
			"\t\tc: list of the constants (value at x = 0)",
			"\t\tinteger: boolean for turning on / off integer mode. Integer mode is exact, it",
			"\t\t\tworks by effectively flooring the separators of the intervals.",
			"\tReturn:",
			"\t\thull_i: on interval j, line i = hull_i[j] is >= all other lines",
			"\t\thull_x: interval j and j + 1 is separated by x = hull_x[j], (hull_x[j] is the last x in interval j)",
			"\t\"\"\"",
			"\tif integer:",
			"\t\tintersect = lambda i, j: (c[j] - c[i]) // (m[i] - m[j])",
			"\telse:",
			"\t\tintersect = lambda i, j: (c[j] - c[i]) / (m[i] - m[j])",
			"\thull_i = []",
			"\thull_x = []",
			"\torder = sorted(range(len(m)), key=m.__getitem__)",
			"\tfor i in order:",
			"\t\twhile True:",
			"\t\t\tif not hull_i:",
			"\t\t\t\thull_i.append(i)",
			"\t\t\t\tbreak",
			"\t\t\telif m[hull_i[-1]] == m[i]:",
			"\t\t\t\tif c[hull_i[-1]] >= c[i]:",
			"\t\t\t\t\tbreak",
			"\t\t\t\thull_i.pop()",
			"\t\t\t\tif hull_x: hull_x.pop()",
			"\t\t\telse:",
			"\t\t\t\tx = intersect(i, hull_i[-1])",
			"\t\t\t\tif hull_x and x <= hull_x[-1]:",
			"\t\t\t\t\thull_i.pop()",
			"\t\t\t\t\thull_x.pop()",
			"\t\t\t\telse:",
			"\t\t\t\t\thull_i.append(i)",
			"\t\t\t\t\thull_x.append(x)",
			"\t\t\t\t\tbreak",
			"\treturn hull_i, hull_x",
			"def max_query(x, m, c, hull_i, hull_x):",
			"\t\"\"\" Find maximum value at x in O(log n) time \"\"\"",
			"\ti = hull_i[bisect_left(hull_x, x)]",
			"\treturn m[i] * x + c[i]"
		],
		"description": "Convex hull trick for maximum queries"
	},
    "pnc": {
        "prefix": "pnc",
        "body": [
            "class Factorial:",
            "\tdef __init__(self, N, mod):",
            "\t\tN += 1",
            "\t\tself.mod = mod",
            "\t\tself.f = [1 for _ in range(N)]",
            "\t\tself.g = [1 for _ in range(N)]",
            "\t\tfor i in range(1, N):",
            "\t\t\tself.f[i] = self.f[i - 1] * i % self.mod",
            "\t\tself.g[-1] = pow(self.f[-1], mod - 2, mod)",
            "\t\tfor i in range(N - 2, -1, -1):",
            "\t\t\tself.g[i] = self.g[i + 1] * (i + 1) % self.mod",
            "\tdef fac(self, n):",
            "\t\treturn self.f[n]",
            "\tdef fac_inv(self, n):",
            "\t\treturn self.g[n]",
            "\tdef combi(self, n, m):",
            "\t\tif m == 0: return 1",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod",
            "\tdef permu(self, n, m):",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[n - m] % self.mod",
            "\tdef catalan(self, n):",
            "\t\treturn (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod",
            "\tdef inv(self, n):",
            "\t\treturn self.f[n-1] * self.g[n] % self.mod"
        ],
        "description": "Class for efficient computation of factorials, combinations, permutations, Catalan numbers, and modular inverses with precomputation."
    },
    "numtheory": {
        "prefix": "numtheory",
        "body": [
            "def matmul(A,B,MOD=(10**9 + 7)):",
            "\tans = [[0 for i in range(len(B[0]))] for j in range(len(A))]",
            "\tfor i in range(len(A)):",
            "\t\tfor j in range(len(B[0])):",
            "\t\t\tfor k in range(len(B)):",
            "\t\t\t\tans[i][j] = (ans[i][j]+A[i][k]*B[k][j])%MOD",
            "\treturn ans",
            "",
            "def matpow(M,power):",
            "\tsize = len(M)",
            "\tresult = [[1 if i == j else 0 for j in range(size)] for i in range(size)]",
            "\twhile power:",
            "\t\tif power % 2 == 1:",
            "\t\t\tresult = matmul(result, M)",
            "\t\tM = matmul(M, M)",
            "\t\tpower //= 2",
            "\treturn result",
            "",
            "def sieve(n):",
            "\tprimes = []",
            "\tisp = [1] * (n+1)",
            "\tisp[0] = isp[1] = 0",
            "\tfor i in range(2,n+1):",
            "\t\tif isp[i]:",
            "\t\t\tprimes.append(i)",
            "\t\t\tfor j in range(i*i,n+1,i):",
            "\t\t\t\tisp[j] = 0",
            "\treturn primes",
            "",
            "def miller_is_prime(n):",
            "\t\"\"\"",
            "\t\tMiller-Rabin test - O(7 * log2n)",
            "\t\tHas 100% success rate for numbers less than 3e+9",
            "\t\tuse it in case of TC problem",
            "\t\"\"\"",
            "\tif n < 5 or n & 1 == 0 or n % 3 == 0:",
            "\t\treturn 2 <= n <= 3",
            "\ts = ((n - 1) & (1 - n)).bit_length() - 1",
            "\td = n >> s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:",
            "\t\t\tcontinue",
            "\t\tfor _ in range(s):",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == n - 1:",
            "\t\t\t\tbreak",
            "\t\telse:",
            "\t\t\treturn False",
            "\treturn True",
            "",
            "def is_prime(n):",
            "\tif n <= 1:",
            "\t\treturn False",
            "\tif n <= 3:",
            "\t\treturn True",
            "\tif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\ti = 5",
            "\twhile i * i <= n:",
            "\t\tif n % i == 0 or n % (i + 2) == 0:",
            "\t\t\treturn False",
            "\t\ti += 6",
            "\treturn True",
            "",
            "def all_factors(n):",
            "\t\"\"\"",
            "\treturns a sorted list of all distinct factors of n",
            "\t\"\"\"",
            "\tsmall, large = [], []",
            "\tfor i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):",
            "\t\tif not n % i:",
            "\t\t\tsmall.append(i)",
            "\t\t\tlarge.append(n // i)",
            "\tif small[-1] == large[-1]:",
            "\t\tlarge.pop()",
            "\tlarge.reverse()",
            "\tsmall.extend(large)",
            "\treturn small",
            "",
            "def sieve_unique(N):",
            "\tmini = [i for i in range(N)]",
            "\tfor i in range(2,N):",
            "\t\tif mini[i]==i:",
            "\t\t\tfor j in range(2*i,N,i):",
            "\t\t\t\tmini[j] = i",
            "\treturn mini",
            "",
            "def prime_factors(k):",
            "\t\"\"\"",
            "\t\tWhen the numbers are large this is the best method to get",
            "\t\tunique prime factors, precompute n log n log n , then each query is log n",
            "\t\"\"\"",
            "\tLmini = [] #precalculate this upto the number required",
            "\t# this should not be here , it should be global and contain the mini made in sieve_unique",
            "\t# dont forget",
            "",
            "\tans = []",
            "\twhile k!=1:",
            "\t\tans.append(Lmini[k])",
            "\t\tk //= Lmini[k]",
            "\treturn ans"
        ],
        "description": "numtheory implementation"
    },
    "SortedList": {
        "prefix": "bsortl",
        "body": [
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "T = TypeVar('T')",
            "class SortedList(Generic[T]):",
            "\tBUCKET_RATIO = 16",
            "\tSPLIT_RATIO = 24",
            "\tdef __init__(self, a: Iterable[T] = []) -> None:",
            "\t\ta = list(a)",
            "\t\tn = self.size = len(a)",
            "\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
            "\t\t\ta.sort()",
            "\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "\tdef __iter__(self) -> Iterator[T]:",
            "\t\tfor i in self.a:",
            "\t\t\tfor j in i: yield j",
            "\tdef __reversed__(self) -> Iterator[T]:",
            "\t\tfor i in reversed(self.a):",
            "\t\t\tfor j in reversed(i): yield j",
            "\tdef __eq__(self, other) -> bool:",
            "\t\treturn list(self) == list(other)",
            "\tdef __len__(self) -> int:",
            "\t\treturn self.size",
            "\tdef __repr__(self) -> str:",
            "\t\treturn \"SortedMultiset\" + str(self.a)",
            "\tdef __str__(self) -> str:",
            "\t\ts = str(list(self))",
            "\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
            "\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
            "\t\tfor i, a in enumerate(self.a):",
            "\t\t\tif x <= a[-1]: break",
            "\t\treturn (a, i, bisect_left(a, x))",
            "\tdef __contains__(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, _, i = self._position(x)",
            "\t\treturn i != len(a) and a[i] == x",
            "\tdef count(self, x: T) -> int:",
            "\t\treturn self.index_right(x) - self.index(x)",
            "\tdef insert(self, x: T) -> None:",
            "\t\tif self.size == 0:",
            "\t\t\tself.a = [[x]]",
            "\t\t\tself.size = 1",
            "\t\t\treturn",
            "\t\ta, b, i = self._position(x)",
            "\t\ta.insert(i, x)",
            "\t\tself.size += 1",
            "\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
            "\t\t\tmid = len(a) >> 1",
            "\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
            "\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
            "\t\tans = a.pop(i)",
            "\t\tself.size -= 1",
            "\t\tif not a: del self.a[b]",
            "\t\treturn ans",
            "\tdef remove(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, b, i = self._position(x)",
            "\t\tif i == len(a) or a[i] != x: return False",
            "\t\tself._pop(a, b, i)",
            "\t\treturn True",
            "\tdef lt(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] < x:",
            "\t\t\t\treturn a[bisect_left(a, x) - 1]",
            "\tdef le(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] <= x:",
            "\t\t\t\treturn a[bisect_right(a, x) - 1]",
            "\tdef gt(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn a[bisect_right(a, x)]",
            "\tdef ge(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn a[bisect_left(a, x)]",
            "\tdef __getitem__(self, i: int) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor a in reversed(self.a):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return a[i]",
            "\t\telse:",
            "\t\t\tfor a in self.a:",
            "\t\t\t\tif i < len(a): return a[i]",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef pop(self, i: int = -1) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor b, a in enumerate(reversed(self.a)):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
            "\t\telse:",
            "\t\t\tfor b, a in enumerate(self.a):",
            "\t\t\t\tif i < len(a): return self._pop(a, b, i)",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef index(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn ans + bisect_left(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef index_right(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn ans + bisect_right(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef find_closest(self, k: T) -> Optional[T]:",
            "\t\tif self.size == 0:",
            "\t\t\treturn None",
            "\t\tltk = self.le(k)",
            "\t\tgtk = self.ge(k)",
            "\t\tif ltk is None:",
            "\t\t\treturn gtk",
            "\t\tif gtk is None:",
            "\t\t\treturn ltk",
            "\t\tif abs(k-ltk)<=abs(k-gtk):",
            "\t\t\treturn ltk",
            "\t\telse:",
            "\t\t\treturn gtk"
        ],
        "description": "SortedList using buckets"
    },    
    "SegmentTree": {
        "prefix": "SegmentTree",
        "body": [
            "class SegmentTree:",
            "\tdef __init__(self, data, default=0, func=max):",
            "\t\t# don't forget to change func here",
            "\t\t# default is the value given to it byy default",
            "\t\tself._default = default",
            "\t\tself._func = func",
            "",
            "\t\tself._len = len(data)",
            "\t\tself._size = _size = 1 << (self._len - 1).bit_length()",
            "\t\tself._lazy = [0] * (2 * _size)",
            "",
            "\t\tself.data = [default] * (2 * _size)",
            "\t\tself.data[_size:_size + self._len] = data",
            "\t\tfor i in reversed(range(_size)):",
            "\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])",
            "\tdef __len__(self):",
            "\t\treturn self._len",
            "\tdef _push(self, idx):",
            "\t\tq, self._lazy[idx] = self._lazy[idx], 0",
            "\t\tself._lazy[2 * idx] += q",
            "\t\tself._lazy[2 * idx + 1] += q",
            "\t\tself.data[2 * idx] += q",
            "\t\tself.data[2 * idx + 1] += q",
            "\tdef _update(self, idx):",
            "\t\tfor i in reversed(range(1, idx.bit_length())):",
            "\t\t\tself._push(idx >> i)",
            "\tdef _build(self, idx):",
            "\t\tidx >>= 1",
            "\t\twhile idx:",
            "\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]",
            "\t\t\tidx >>= 1",
            "\tdef add(self, start, stop, value):",
            "\t\t# lazily add value to [start, stop)",
            "\t\tstart = start_copy = start + self._size",
            "\t\tstop = stop_copy = stop + self._size",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tself._lazy[start] += value",
            "\t\t\t\tself.data[start] += value",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tself._lazy[stop] += value",
            "\t\t\t\tself.data[stop] += value",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\tself._build(start_copy)",
            "\t\tself._build(stop_copy - 1)",
            "\tdef query(self, start, stop, default=-float('inf')):",
            "\t\t# func of data[start, stop)",
            "\t\t# don't forget to update the default",
            "\t\tstart += self._size",
            "\t\tstop += self._size",
            "\t\tself._update(start)",
            "\t\tself._update(stop - 1)",
            "\t\tres = default",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tres = self._func(res, self.data[start])",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tres = self._func(res, self.data[stop])",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\treturn res",
            "\tdef __repr__(self):",
            "\t\treturn \"LazySegmentTree({0})\".format(self.data)"
        ],
        "description": "Segment Tree implementation with lazy propagation in which returned is one of the input"
    },
    "SegmentOther": {
        "prefix": "SegmentOther",
        "body": [
            "class SegmentTree:",
            "\t# all the operations in here are inclusive of l to r",
            "\t# later on make it custom for each func like seg point",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\t# Change this function depending upon needs",
            "\t\treturn a+b",
            "\tdef __init__(self, arr):",
            "\t\tself.arr = arr",
            "\t\tself.n = len(arr)",
            "\t\tself.tree = [0] * (4 * self.n)",
            "\t\tself.lazy = [0] * (4 * self.n)",
            "\t\tself.build_tree(1, 0, self.n - 1)",
            "\tdef build_tree(self, node, start, end):",
            "\t\tif start == end:",
            "\t\t\tself.tree[node] = self.arr[start]",
            "\t\telse:",
            "\t\t\tmid = (start + end) // 2",
            "\t\t\tself.build_tree(2 * node, start, mid)",
            "\t\t\tself.build_tree(2 * node + 1, mid + 1, end)",
            "\t\t\tself.tree[node] = self.func(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef propagate_lazy(self, node, start, end):",
            "\t\tif self.lazy[node] != 0:",
            "\t\t\tself.tree[node] += self.lazy[node]",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += self.lazy[node]",
            "\t\t\t\tself.lazy[2 * node + 1] += self.lazy[node]",
            "\t\t\tself.lazy[node] = 0",
            "\tdef update(self, node, start, end, l, r, value):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn",
            "\t\tif start >= l and end <= r:",
            "\t\t\tself.tree[node] += value",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += value",
            "\t\t\t\tself.lazy[2 * node + 1] += value",
            "\t\t\treturn",
            "\t\tmid = (start + end) // 2",
            "\t\tself.update(2 * node, start, mid, l, r, value)",
            "\t\tself.update(2 * node + 1, mid + 1, end, l, r, value)",
            "\t\tself.tree[node] = self.func(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef range_update(self, l, r, value):",
            "\t\tself.update(1, 0, self.n - 1, l, r, value)",
            "\tdef query(self, node, start, end, l, r):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn 0",
            "\t\tif start >= l and end <= r:",
            "\t\t\treturn self.tree[node]",
            "\t\tmid = (start + end) // 2",
            "\t\treturn self.func(self.query(2 * node, start, mid, l, r),",
            "\t\t\t\t   self.query(2 * node + 1, mid + 1, end, l, r))",
            "\tdef range_query(self, l, r):",
            "\t\treturn self.query(1, 0, self.n - 1, l, r)",
            "\tdef to_list(self):",
            "\t\tresult = []",
            "\t\tfor i in range(self.n):",
            "\t\t\tresult.append(self.range_query(i, i))",
            "\t\treturn result"
        ],
        "description": "Segment Tree for other Operations with lazy propogation"
    },
	"sortl": {
        "prefix": "fsortl",
        "body": [
            "class FenwickTree:",
            "\tdef __init__(self, x):",
            "\t\tbit = self.bit = list(x)",
            "\t\tsize = self.size = len(bit)",
            "\t\tfor i in range(size):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < size:",
            "\t\t\t\tbit[j] += bit[i]",
            "\tdef update(self, idx, x):",
            "\t\twhile idx < self.size:",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef __call__(self, end):",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1 ",
            "\t\treturn x",
            "\tdef find_kth(self, k):",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(self.size.bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < self.size and self.bit[right_idx] <= k:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1, k",
            "class SortedList:",
            "\tblock_size = 700",
            "\tdef __init__(self, iterable=()):",
            "\t\tself.macro = []",
            "\t\tself.micros = [[]]",
            "\t\tself.micro_size = [0]",
            "\t\tself.fenwick = FenwickTree([0])",
            "\t\tself.size = 0",
            "\t\tfor item in iterable:",
            "\t\t\tself.insert(item)",
            "\tdef insert(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\tj = bisect_right(self.micros[i], x)",
            "\t\tself.micros[i].insert(j, x)",
            "\t\tself.size += 1",
            "\t\tself.micro_size[i] += 1",
            "\t\tself.fenwick.update(i, 1)",
            "\t\tif len(self.micros[i]) >= self.block_size:",
            "\t\t\tself.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]",
            "\t\t\tself.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1",
            "\t\t\tself.fenwick = FenwickTree(self.micro_size)",
            "\t\t\tself.macro.insert(i, self.micros[i + 1][0])",
            "\tdef add(self, x):",
            "\t\tself.insert(x)",
            "\tdef pop(self, k=-1):",
            "\t\ti, j = self._find_kth(k)",
            "\t\tself.size -= 1",
            "\t\tself.micro_size[i] -= 1",
            "\t\tself.fenwick.update(i, -1)",
            "\t\treturn self.micros[i].pop(j)",
            "\tdef remove(self, N: int):",
            "\t\tidx = self.bisect_left(N)",
            "\t\tself.pop(idx)",
            "\tdef __getitem__(self, k):",
            "\t\ti, j = self._find_kth(k)",
            "\t\treturn self.micros[i][j]",
            "\tdef count(self, x):",
            "\t\treturn self.bisect_right(x) - self.bisect_left(x)",
            "\tdef __contains__(self, x):",
            "\t\treturn self.count(x) > 0",
            "\tdef bisect_left(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_left(self.micros[i], x)",
            "\tdef bisect_right(self, x):",
            "\t\ti = bisect_right(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_right(self.micros[i], x)",
            "\tdef _find_kth(self, k):",
            "\t\treturn self.fenwick.find_kth(k + self.size if k < 0 else k)",
            "\tdef __len__(self):",
            "\t\treturn self.size",
            "\tdef __iter__(self):",
            "\t\treturn (x for micro in self.micros for x in micro)",
            "\tdef __repr__(self):",
            "\t\treturn str(list(self))"
        ],
        "description": "sorted list using fenwick tree use for insertion,deletion,traversel in log(n)"
    },
    "bootstrap": {
        "prefix": "bootstrap",
        "body": [
            "from types import GeneratorType",
            "",
            "def bootstrap(f, stack=[]):",
            "\tdef wrappedfunc(*args, **kwargs):",
            "\t\tif stack:",
            "\t\t\treturn f(*args, **kwargs)",
            "\t\telse:",
            "\t\t\tto = f(*args, **kwargs)",
            "\t\t\twhile True:",
            "\t\t\t\tif type(to) is GeneratorType:",
            "\t\t\t\t\tstack.append(to)",
            "\t\t\t\t\tto = next(to)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.pop()",
            "\t\t\t\t\tif not stack:",
            "\t\t\t\t\t\tbreak",
            "\t\t\t\t\tto = stack[-1].send(to)",
            "\t\t\treturn to",
            "\treturn wrappedfunc",
            "",
            "# @bootstrap",
            "# put this just on top of recursion function to increase the recursion limit",
            "",
            "# rather than return now use yield and when function being called inside itself, use yield before the function name",
            "# example usage:",
            "# @bootstrap",
            "# def rec1(L,k,cur,count):",
            "# \tif count>=100000:",
            "# \t\tyield float('INF')",
            "# \tif cur+k+1>=len(L)-1:",
            "# \t\tyield L[cur]+2",
            "# \tif cur in d:",
            "# \t\tyield d[cur]",
            "# \tans = float('INF')",
            "# \tmini = float('INF')",
            "# \tfor i in range(k+1,0,-1):",
            "# \t\tif L[cur+i]<mini:",
            "# \t\t\tans = min(ans,1+L[cur]+(yield rec1(L,k,cur+i,count+1)))",
            "# \t\t\tmini = L[cur+i]",
            "# \td[cur] = ans",
            "# \tyield ans",
            "# the limit of recursion on cf is 10**6"
        ],
        "description": "Decorator to increase recursion limit using the bootstrap method with yield."
    },
    "sh": {
        "prefix": "sh",
        "body": [
            "def getSubHash(left,right,hash,power):",
            "\t#returns hash value of [left,right]",
            "\t#check for two diff hash,power to prevent collision",
            "\t#change MOD according to how many values you want ,",
            "\t#the more the value , lesser the collisiosn",
            "\tleft += 1",
            "\tright += 1",
            "\th1 = hash[right]",
            "\th2 = (hash[left - 1] * power[right - left + 1]) % MOD",
            "\treturn (h1 + MOD - h2) % MOD",
            "n = len(st)",
            "hash = [0] * (n + 1)",
            "# hash1 = [0] * (n + 1)",
            "power = [0] * (n + 1)",
            "# power1 = [0] * (n + 1)",
            "P = 131",
            "# P1 = 132",
            "power[0] = 1",
            "# power1[0] = 1",
            "for i in range(n):",
            "\tpower[i + 1] = (power[i] * P) % MOD",
            "\t# power1[i+1] = (power1[i] * P1) % MOD",
            "\thash[i + 1] = (hash[i] * P + ord(st[i])) % MOD",
            "\t# hash1[i + 1] = (hash1[i] * P1 + ord(st[i])) % MOD",
            "",
            "def z_function(S):",
            "\t# return: the Z array, where Z[i] = length of the longest common prefix of S[i:] and S",
            "\tn = len(S)",
            "\tZ = [0] * n",
            "\tl = r = 0",
            "\tfor i in range(1, n):",
            "\t\tz = Z[i - l]",
            "\t\tif i + z >= r:",
            "\t\t\tz = max(r - i, 0)",
            "\t\t\twhile i + z < n and S[z] == S[i + z]:",
            "\t\t\t\tz += 1",
            "\t\t\tl, r = i, i + z",
            "\t\tZ[i] = z",
            "\tZ[0] = n",
            "\treturn Z",
            ""
        ],
        "description": "sh implementation"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "class BIT:",
            "\t#Faster than segment tree so use if possbile",
            "\tdef __init__(self, x):",
            "\t\t\"\"\"transform list into BIT\"\"\"",
            "\t\tself.bit = x",
            "\t\tfor i in range(len(x)):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < len(x):",
            "\t\t\t\tx[j] += x[i]",
            "\tdef update(self, idx, x):",
            "\t\t\"\"\"updates bit[idx] += x\"\"\"",
            "\t\t#basically after that number greater greater than x will be added",
            "\t\twhile idx < len(self.bit):",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef query(self, end):",
            "\t\t\"\"\"calc sum(bit[:end])\"\"\"",
            "\t\t#gives sum of element before end",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1",
            "\t\treturn x",
            "\tdef findkth(self, k):",
            "\t\t\"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(len(self.bit).bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1"
        ]
    },
    "SegmentPoint": {
        "prefix": "SegmentPoint",
        "body": [
            "class SegmentTree:",
            "\t\"\"\"",
            "\t\tRemember to change the func content as well as the initializer to display the content",
            "\t\"\"\"",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\t# Change this function depending upon needs",
            "\t\treturn max(a, b)",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [0] * (2 * self.n)",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i] = data[i]",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1])",
            "\tdef update(self, pos, value):",
            "\t\t# Update the value at the leaf node",
            "\t\tpos += self.n",
            "\t\t# For updating",
            "\t\tself.tree[pos] = value",
            "\t\t# self.tree[pos] += value",
            "\t\t# If you want to add rather than update",
            "\t\twhile pos > 1:",
            "\t\t\tpos //= 2",
            "\t\t\tself.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1])",
            "\tdef query(self, left, right):",
            "\t\t# Query the maximum value in the range [left, right)",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\t# Change the initializer depending upon the self.func",
            "\t\tmax_val = float('-inf')",
            "\t\t##",
            "\t\twhile left < right:",
            "\t\t\tif left % 2:",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[left])",
            "\t\t\t\tleft += 1",
            "\t\t\tif right % 2:",
            "\t\t\t\tright -= 1",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[right])",
            "\t\t\tleft //= 2",
            "\t\t\tright //= 2",
            "\t\treturn max_val"
        ],
        "description": "Segment Tree implementation better for point updates and range queries"
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "class SparseTable:",
            "\t@staticmethod",
            "\tdef func(a,b):",
            "\t\treturn gcd(a,b)",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.table = [[0 for i in range(int((math.log(self.n, 2)+1)))] for j in range(self.n)]",
            "\t\tself.build(arr)",
            "\tdef build(self, arr):",
            "\t\tfor i in range(0, self.n):",
            "\t\t\tself.table[i][0] = arr[i]",
            "\t\tj = 1",
            "\t\twhile (1 << j) <= self.n:",
            "\t\t\ti = 0",
            "\t\t\twhile i <= self.n - (1 << j):",
            "\t\t\t\tself.table[i][j] = self.func(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])",
            "\t\t\t\ti += 1",
            "\t\t\tj += 1",
            "\tdef query(self, L, R):",
            "\t\tj = int(math.log2(R - L + 1))",
            "\t\treturn self.func(self.table[L][j], self.table[R - (1 << j) + 1][j])"
        ],
        "description": "Sparse Table"
    },
    "dpheq": {
        "prefix": "dpheq",
        "body": [
            "class DiophantineEquations:",
            "\t\"\"\"",
            "\t\tused for solving equations of the form a*x + b*y = c,",
            "\t\tsolnll takes the lower limit as well",
            "\t\"\"\"",
            "\tdef __init__(self):",
            "\t\tpass",
            "\tdef euclidean_gcd(self,a, b):",
            "\t\t\"\"\"",
            "\t\t\teuclidean gcd , returns x and y such that",
            "\t\t\ta*x + b*y = gcd(a,b)",
            "\t\t\"\"\"",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.euclidean_gcd(b, a % b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef soln(self,a,b,c,t=10**18,t1=10**18):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and 0<=m<=t and 0<=n<=t1",
            "\t\t\tdon't input t,t1 for any possible value",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c%g!=0:",
            "\t\t\treturn -1,-1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x*(c//g)",
            "\t\tn1 = y*(c//g)",
            "\t\tk1 = max(math.ceil(-k3*g/b),math.ceil((n1-t1)/(a/g)))",
            "\t\tkmaxi = min(math.floor((t-k3)/(b/g)), math.floor(n1/(a/g)))",
            "\t\tif k1<=kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3+k*(b//g)",
            "\t\t\tn = n1-k*(a//g)",
            "\t\t\treturn m, n",
            "\t\telse:",
            "\t\t\treturn -1,-1",
            "\tdef sollnll(self,a,b,c,t,t1,m_lower,n_lower):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and",
            "\t\t\tm_lower <= m <= t and n_lower <= n <= t1",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c % g != 0:",
            "\t\t\treturn -1, -1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x * (c // g)",
            "\t\tn1 = y * (c // g)",
            "\t\tk1 = max(math.ceil((m_lower - k3 * g) / b), math.ceil((n1 - t1) / (a / g)))",
            "\t\tkmaxi = min(math.floor((t - k3) / (b / g)), math.floor((n1 - n_lower) / (a / g)))",
            "\t\tif k1 <= kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3 + k * (b // g)",
            "\t\t\tn = n1 - k * (a // g)",
            "\t\t\tif m_lower <= m <= t and n_lower <= n <= t1:",
            "\t\t\t\treturn m, n",
            "\t\t\telse:",
            "\t\t\t\treturn -1,-1",
            "\t\telse:",
            "\t\t\treturn -1, -1",
            "Leq = DiophantineEquations()"
        ],
        "description": "dpheq implementation"
    },
    "graphs": {
        "prefix": "graphs",
        "body": [
            "def bellman_ford(n, edges, start):",
            "\tdist = [float(\"inf\")] * n",
            "\tpred = [None] * n",
            "\tdist[start] = 0",
            "\tfor _ in range(n):",
            "\t\tfor u, v, d in edges:",
            "\t\t\tif dist[u] + d < dist[v]:",
            "\t\t\t\tdist[v] = dist[u] + d",
            "\t\t\t\tpred[v] = u",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return -1",
            "\t# This returns -1 , if there is a negative cycle",
            "",
            "class binary_lift:",
            "\tdef __init__(self, graph, data=(), f=min, root=0):",
            "\t\tn = len(graph)",
            "\t\tparent = [-1] * (n + 1)",
            "\t\tdepth = self.depth = [-1] * n",
            "\t\tbfs = [root]",
            "\t\tdepth[root] = 0",
            "\t\tfor node in bfs:",
            "\t\t\tfor nei in graph[node]:",
            "\t\t\t\tif depth[nei] == -1:",
            "\t\t\t\t\tparent[nei] = node",
            "\t\t\t\t\tdepth[nei] = depth[node] + 1",
            "\t\t\t\t\tbfs.append(nei)",
            "",
            "\t\tdata = self.data = [data]",
            "\t\tparent = self.parent = [parent]",
            "\t\tself.f = f",
            "",
            "\t\tfor _ in range(max(depth).bit_length()):",
            "\t\t\told_data = data[-1]",
            "\t\t\told_parent = parent[-1]",
            "\t\t\tdata.append([f(val, old_data[p]) for val,p in zip(old_data, old_parent)])",
            "\t\t\tparent.append([old_parent[p] for p in old_parent])",
            "",
            "\tdef lca(self, a, b):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tif depth[a] < depth[b]:",
            "\t\t\ta,b = b,a",
            "\t\td = depth[a] - depth[b]",
            "\t\tfor i in range(d.bit_length()):",
            "\t\t\tif (d >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\tfor i in range(depth[a].bit_length())[::-1]:",
            "\t\t\tif parent[i][a] != parent[i][b]:",
            "\t\t\t\ta = parent[i][a]",
            "\t\t\t\tb = parent[i][b]",
            "\t\tif a != b:",
            "\t\t\treturn parent[0][a]",
            "\t\telse:",
            "\t\t\treturn a",
            "\tdef distance(self, a, b):",
            "\t\treturn self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a,b)]",
            "\tdef kth_ancestor(self, a, k):",
            "\t\tparent = self.parent",
            "\t\tif self.depth[a] < k:",
            "\t\t\treturn -1",
            "\t\tfor i in range(k.bit_length()):",
            "\t\t\tif (k >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\treturn a",
            "\tdef __call__(self, a, b):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tdata = self.data",
            "\t\tf = self.f",
            "\t\tc = self.lca(a, b)",
            "\t\tval = data[0][c]",
            "\t\tfor x,d in (a, depth[a] - depth[c]), (b, depth[b] - depth[c]):",
            "\t\t\tfor i in range(d.bit_length()):",
            "\t\t\t\tif (d >> i) & 1:",
            "\t\t\t\t\tval = f(val, data[i][x])",
            "\t\t\t\t\tx = parent[i][x]",
            "\t\treturn val",
            "",
            "def floyd_warshall(n, edges):",
            "\tdist = [[0 if i == j else float(\"inf\") for i in range(n)] for j in range(n)]",
            "\tpred = [[None] * n for _ in range(n)]",
            "",
            "\tfor u, v, d in edges:",
            "\t\tdist[u][v] = d",
            "\t\tpred[u][v] = u",
            "",
            "\tfor k in range(n):",
            "\t\tfor i in range(n):",
            "\t\t\tfor j in range(n):",
            "\t\t\t\tif dist[i][k] + dist[k][j] < dist[i][j]:",
            "\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]",
            "\t\t\t\t\tpred[i][j] = pred[k][j]",
            "\t# Sanity Check",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return None",
            "",
            "\treturn dist, pred",
            "",
            "def dijkstra(graph, start ,n):",
            "\tdist, parents = [float(\"inf\")] * n, [-1] * n",
            "\tdist[start] = 0",
            "\tqueue = [(0, start)]",
            "\twhile queue:",
            "\t\tpath_len, v = heappop(queue)",
            "\t\tif path_len == dist[v]:",
            "\t\t\tfor w, edge_len in graph[v]:",
            "\t\t\t\tif edge_len + path_len < dist[w]:",
            "\t\t\t\t\tdist[w], parents[w] = edge_len + path_len, v",
            "\t\t\t\t\theappush(queue, (edge_len + path_len, w))",
            "\treturn dist, parents",
            "",
            "def toposort(graph):",
            "\tres, found = [], [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\tres.append(~node)",
            "\t\telif not found[node]:",
            "\t\t\tfound[node] = 1",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\tfor node in res:",
            "\t\tif any(found[nei] for nei in graph[node]):",
            "\t\t\treturn None",
            "\t\tfound[node] = 0",
            "\treturn res[::-1]",
            "",
            "def kahn(graph):",
            "\tn = len(graph)",
            "\tindeg, idx = [0] * n, [0] * n",
            "\tfor i in range(n):",
            "\t\tfor e in graph[i]:",
            "\t\t\tindeg[e] += 1",
            "\tq, res = [], []",
            "\tfor i in range(n):",
            "\t\tif indeg[i] == 0:",
            "\t\t\tq.append(i)",
            "\tnr = 0",
            "\twhile q:",
            "\t\tres.append(q.pop())",
            "\t\tidx[res[-1]], nr = nr, nr + 1",
            "\t\tfor e in graph[res[-1]]:",
            "\t\t\tindeg[e] -= 1",
            "\t\t\tif indeg[e] == 0:",
            "\t\t\t\tq.append(e)",
            "\treturn res, idx, nr == n",
            "",
            "def dfs(graph, start=0):",
            "\tn = len(graph)",
            "\tdp = [0] * n",
            "\tvisited, finished = [False] * n, [False] * n",
            "\tstack = [start]",
            "\twhile stack:",
            "\t\tstart = stack[-1]",
            "\t\tif not visited[start]:",
            "\t\t\tvisited[start] = True",
            "\t\t\tfor child in graph[start]:",
            "\t\t\t\tif not visited[child]:",
            "\t\t\t\t\tstack.append(child)",
            "\t\telse:",
            "\t\t\tstack.pop()",
            "\t\t\tdp[start] += 1",
            "\t\t\tfor child in graph[start]:",
            "\t\t\t\tif finished[child]:",
            "\t\t\t\t\tdp[start] += dp[child]",
            "\t\t\tfinished[start] = True",
            "\treturn visited, dp",
            "",
            "def rec(cur,color):",
            "\t# If asking for SCC, rather than d, use the reversed graph",
            "\t# Also the traversel should be in reverse of topological order",
            "\tvisited = [],ans = [],d = {} # remove this",
            "\tvisited[cur] = True",
            "\tans[cur] = color",
            "\tfor i in d[cur]:",
            "\t\tif visited[i]:",
            "\t\t\tcontinue",
            "\t\tans1 = (yield rec(i,color))",
            "\tyield -1",
            "",
            "def euler_path(d):",
            "\tstart = [1]",
            "\tans = []",
            "\twhile start:",
            "\t\tcur = start[-1]",
            "\t\tif len(d[cur])==0:",
            "\t\t\tans.append(cur)",
            "\t\t\tstart.pop()",
            "\t\t\tcontinue",
            "\t\tk1 = d[cur].pop()",
            "\t\td[k1].remove(cur)",
            "\t\tstart.append(k1)",
            "\treturn ans",
            "",
            "INF = float(\"inf\")",
            "class Dinic:",
            "\tdef __init__(self, n):",
            "\t\tself.lvl = [0] * n",
            "\t\tself.ptr = [0] * n",
            "\t\tself.q = [0] * n",
            "\t\tself.adj = [[] for _ in range(n)]",
            "\tdef add_edge(self, a, b, c, rcap=0):",
            "\t\tself.adj[a].append([b, len(self.adj[b]), c, 0])",
            "\t\tself.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])",
            "\tdef dfs(self, v, t, f):",
            "\t\tif v == t or not f:",
            "\t\t\treturn f",
            "\t\tfor i in range(self.ptr[v], len(self.adj[v])):",
            "\t\t\te = self.adj[v][i]",
            "\t\t\tif self.lvl[e[0]] == self.lvl[v] + 1:",
            "\t\t\t\tp = self.dfs(e[0], t, min(f, e[2] - e[3]))",
            "\t\t\t\tif p:",
            "\t\t\t\t\tself.adj[v][i][3] += p",
            "\t\t\t\t\tself.adj[e[0]][e[1]][3] -= p",
            "\t\t\t\t\treturn p",
            "\t\t\tself.ptr[v] += 1",
            "\t\treturn 0",
            "\tdef calc(self, s, t):",
            "\t\tflow, self.q[0] = 0, s",
            "\t\tfor l in range(31):  # l = 30 maybe faster for random data",
            "\t\t\twhile True:",
            "\t\t\t\tself.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)",
            "\t\t\t\tqi, qe, self.lvl[s] = 0, 1, 1",
            "\t\t\t\twhile qi < qe and not self.lvl[t]:",
            "\t\t\t\t\tv = self.q[qi]",
            "\t\t\t\t\tqi += 1",
            "\t\t\t\t\tfor e in self.adj[v]:",
            "\t\t\t\t\t\tif not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):",
            "\t\t\t\t\t\t\tself.q[qe] = e[0]",
            "\t\t\t\t\t\t\tqe += 1",
            "\t\t\t\t\t\t\tself.lvl[e[0]] = self.lvl[v] + 1",
            "\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\twhile p:",
            "\t\t\t\t\tflow += p",
            "\t\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\tif not self.lvl[t]:",
            "\t\t\t\t\tbreak",
            "\t\treturn flow",
            "",
            "def find_SCC(graph):",
            "\tSCC, S, P = [], [], []",
            "\tdepth = [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\td = depth[~node] - 1",
            "\t\t\tif P[-1] > d:",
            "\t\t\t\tSCC.append(S[d:])",
            "\t\t\t\tdel S[d:], P[-1]",
            "\t\t\t\tfor node in SCC[-1]:",
            "\t\t\t\t\tdepth[node] = -1",
            "\t\telif depth[node] > 0:",
            "\t\t\twhile P[-1] > depth[node]:",
            "\t\t\t\tP.pop()",
            "\t\telif depth[node] == 0:",
            "\t\t\tS.append(node)",
            "\t\t\tP.append(len(S))",
            "\t\t\tdepth[node] = len(S)",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\treturn SCC[::-1]",
            "",
            "class TwoSat:",
            "\tdef __init__(self, n):",
            "\t\tself.n = n",
            "\t\tself.graph = [[] for _ in range(2 * n)]",
            "\tdef _imply(self, x, y):",
            "\t\tself.graph[x].append(y if y >= 0 else 2 * self.n + y)",
            "\tdef either(self, x, y):",
            "\t\t# either x or y must be True",
            "\t\tself._imply(~x, y)",
            "\t\tself._imply(~y, x)",
            "\tdef set(self, x):",
            "\t\t# x must be True",
            "\t\tself._imply(~x, x)",
            "\tdef solve(self):",
            "\t\tSCC = find_SCC(self.graph)",
            "\t\torder = [0] * (2 * self.n)",
            "\t\tfor i, comp in enumerate(SCC):",
            "\t\t\tfor x in comp:",
            "\t\t\t\torder[x] = i",
            "\t\tfor i in range(self.n):",
            "\t\t\tif order[i] == order[~i]:",
            "\t\t\t\treturn False, None",
            "\t\treturn True, [+(order[i] > order[~i]) for i in range(self.n)]"
        ],
        "description": "graphs implementation"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "class DisjointSetUnion:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "\t\tself.size = [1] * n",
            "\t\tself.num_sets = n",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\ta, b = self.find(a), self.find(b)",
            "\t\tif a != b:",
            "\t\t\tif self.size[a] < self.size[b]:",
            "\t\t\t\ta, b = b, a",
            "",
            "\t\t\tself.num_sets -= 1",
            "\t\t\tself.parent[b] = a",
            "\t\t\tself.size[a] += self.size[b]",
            "",
            "\tdef set_size(self, a):",
            "\t\treturn self.size[self.find(a)]",
            "",
            "\tdef __len__(self):",
            "\t\treturn self.num_sets",
            "",
            "",
            "class UnionFind:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\tself.parent[self.find(b)] = self.find(a)"
        ],
        "description": "DSU implementation"
    },
    "shclass": {
        "prefix": "shclass",
        "body": [
            "HMOD = 2147483647",
            "HBASE1 = random.randrange(HMOD)",
            "HBASE2 = random.randrange(HMOD)",
            "class Hashing:",
            "\tdef __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):",
            "\t\tself.mod, self.base1, self.base2 = mod, base1, base2",
            "\t\tself._len = _len = len(s)",
            "\t\tf_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)",
            "\t\ts_hash, s_pow = f_hash[:], f_pow[:]",
            "\t\tfor i in range(_len):",
            "\t\t\tf_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod",
            "\t\t\ts_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod",
            "\t\t\tf_pow[i + 1] = base1 * f_pow[i] % mod",
            "\t\t\ts_pow[i + 1] = base2 * s_pow[i] % mod",
            "\t\tself.f_hash, self.f_pow = f_hash, f_pow",
            "\t\tself.s_hash, self.s_pow = s_hash, s_pow",
            "\tdef hashed(self, start, stop):",
            "\t\treturn (",
            "\t\t\t(self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,",
            "\t\t\t(self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,",
            "\t\t)",
            "\tdef get_hashes(self, length):",
            "\t\treturn (",
            "\t\t\t[(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t\t[(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t)"
        ],
        "description": "shclass implementation"
    },
    "Geometry": {
        "prefix": "geometry",
        "body": [
            "## here onwards, it is for intersection only, even the point class is different",
            "class Point:",
            "\tdef __init__(self, x, y):",
            "\t\tself.x = x",
            "\t\tself.y = y",
            "def onSegment(p, q, r):",
            "\tif ( (q.x <= max(p.x, r.x)) and (q.x >= min(p.x, r.x)) and",
            "\t\t   (q.y <= max(p.y, r.y)) and (q.y >= min(p.y, r.y))):",
            "\t\treturn True",
            "\treturn False",
            "def orientation(p, q, r):",
            "\t# to find the orientation of an ordered triplet (p,q,r)",
            "\t# function returns the following values:",
            "\t# 0 : Collinear points",
            "\t# 1 : Clockwise points",
            "\t# 2 : Counterclockwise",
            "\tval = ((q.y - p.y) * (r.x - q.x)) - ((q.x - p.x) * (r.y - q.y))",
            "\tif (val > 0):",
            "\t\treturn 1",
            "\telif (val < 0):",
            "\t\treturn 2",
            "\telse:",
            "\t\treturn 0",
            "def doIntersect(p1,q1,p2,q2):",
            "\to1 = orientation(p1, q1, p2)",
            "\to2 = orientation(p1, q1, q2)",
            "\to3 = orientation(p2, q2, p1)",
            "\to4 = orientation(p2, q2, q1)",
            "\tif ((o1 != o2) and (o3 != o4)):",
            "\t\treturn True",
            "\tif ((o1 == 0) and onSegment(p1, p2, q1)):",
            "\t\treturn True",
            "\tif ((o2 == 0) and onSegment(p1, q2, q1)):",
            "\t\treturn True",
            "\tif ((o3 == 0) and onSegment(p2, p1, q2)):",
            "\t\treturn True",
            "\tif ((o4 == 0) and onSegment(p2, q1, q2)):",
            "\t\treturn True",
            "\treturn False",
            "##",
            "",
            "## lines",
            "import itertools",
            "",
            "# 2d line: ax + by + c = 0  is  (a, b, c)",
            "",
            "#\t\t  ax + by + c = 0\t ((a, b, c),",
            "# 3d line: dx + ez + f = 0  is  (d, e, f),",
            "#\t\t  gy + hz + i = 0\t  (g, h, i))",
            "",
            "def get_2dline(p1, p2):",
            "\tif p1 == p2:",
            "\t\treturn (0, 0, 0)",
            "\t_p1, _p2 = min(p1, p2), max(p1, p2)",
            "\ta, b, c = _p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]",
            "\tg = gcd(gcd(a, b), c)",
            "\treturn (a // g, b // g, c // g)",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "get_line = lambda p1, p2: map(get_2dline, itertools.combinations(p1, 2), itertools.combinations(p2, 2))",
            "is_parallel = lambda l1, l2: l1[0] * l2[1] == l2[0] * l1[1]",
            "is_same = lambda l1, l2: is_parallel(l1, l2) and (l1[1] * l2[2] == l2[1] * l1[2])",
            "collinear = lambda p1, p2, p3: is_same(get_2dline(p1, p2), get_2dline(p2, p3))",
            "intersect = (lambda l1, l2: None if is_parallel(l1, l2) else (",
            "\t(l2[1] * l1[2] - l1[1] * l2[2]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "\t(l1[0] * l2[2] - l1[2] * l2[0]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "))",
            "rotate = lambda p, theta, origin=(0, 0): (",
            "\torigin[0] + (p[0] - origin[0]) * math.cos(theta) - (p[1] - origin[1]) * math.sin(theta),",
            "\torigin[1] + (p[0] - origin[0]) * math.sin(theta) + (p[1] - origin[1]) * math.cos(theta),",
            ")",
            "##",
            "",
            "## polygons",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "perimeter = lambda *p: sum(dist(i, j) for i, j in zip(p, p[1:] + p[:1]))",
            "area = lambda *p: abs(sum(i[0] * j[1] - j[0] * i[1] for i, j in zip(p, p[1:] + p[:1]))) / 2",
            "is_in_circle = lambda p, c, r: sum(i * i - j * j for i, j in zip(p, c)) < r * r",
            "incircle_radius = lambda a, b, c: area(a, b, c) / (perimeter(a, b, c) / 2)",
            "circumcircle_radius = lambda a, b, c: (dist(a, b) * dist(b, c) * dist(c, a)) / (4 * area(a, b, c))",
            "##"
        ],
        "description": "Geometry implementation"
    }
}
