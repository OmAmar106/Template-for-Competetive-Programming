{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cp": {
		"prefix": "cp",
		"body": [
			"import sys,math,random",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations",
            "",
            "# functions #",
            "MOD = 998244353",
            "MOD = 10**9 + 7",
			"RANDOM = random.randrange(2**62)",
            "def gcd(a,b):",
			"\tif a%b==0:",
			"\t\treturn b",
			"\telse:",
			"\t\treturn gcd(b,a%b)",
			"def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
			"def w(x):",
			"\treturn x ^ RANDOM",
            "##",
            "",
            "#String hashing : sh, fenwick sortedlist : fsortl, Number : numtheory, SparseTable : SparseTable",
            "#bucket sorted list : bsortl, segment tree(lazy propogation) : SegmentTree, bootstrap : bootstrap",
            "#binary indexed tree : BIT, segment tree(point updates) : SegmentPoint, Convex Hull : hull", 
            "#Combinatorics : pnc, Diophantine Equations : dpheq",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "",
			"def solve():",
			"\tn = int(sys.stdin.readline().strip())",
			"\tL = list(map(int, sys.stdin.readline().split()))",
			"\t#L1 = list(map(int, sys.stdin.readline().split()))",
			"\t#st = sys.stdin.readline().strip()",
			"for _ in range(int(sys.stdin.readline().strip())):",
			"\tsolve()"
	    ],  
		"description": "codeforces template"
	},
    "hull": {
		"prefix": "hull",
		"body": [
			"def convex_hull_trick(m, c, integer=True):",
			"\t\"\"\"",
			"\tGiven lines on the form y = m[i] * x + c[i] this function returns intervals,",
			"\tsuch that on each interval the convex hull is made up of a single line.",
			"\tInput:",
			"\t\tm: list of the slopes",
			"\t\tc: list of the constants (value at x = 0)",
			"\t\tinteger: boolean for turning on / off integer mode. Integer mode is exact, it",
			"\t\t\tworks by effectively flooring the separators of the intervals.",
			"\tReturn:",
			"\t\thull_i: on interval j, line i = hull_i[j] is >= all other lines",
			"\t\thull_x: interval j and j + 1 is separated by x = hull_x[j], (hull_x[j] is the last x in interval j)",
			"\t\"\"\"",
			"\tif integer:",
			"\t\tintersect = lambda i, j: (c[j] - c[i]) // (m[i] - m[j])",
			"\telse:",
			"\t\tintersect = lambda i, j: (c[j] - c[i]) / (m[i] - m[j])",
			"\thull_i = []",
			"\thull_x = []",
			"\torder = sorted(range(len(m)), key=m.__getitem__)",
			"\tfor i in order:",
			"\t\twhile True:",
			"\t\t\tif not hull_i:",
			"\t\t\t\thull_i.append(i)",
			"\t\t\t\tbreak",
			"\t\t\telif m[hull_i[-1]] == m[i]:",
			"\t\t\t\tif c[hull_i[-1]] >= c[i]:",
			"\t\t\t\t\tbreak",
			"\t\t\t\thull_i.pop()",
			"\t\t\t\tif hull_x: hull_x.pop()",
			"\t\t\telse:",
			"\t\t\t\tx = intersect(i, hull_i[-1])",
			"\t\t\t\tif hull_x and x <= hull_x[-1]:",
			"\t\t\t\t\thull_i.pop()",
			"\t\t\t\t\thull_x.pop()",
			"\t\t\t\telse:",
			"\t\t\t\t\thull_i.append(i)",
			"\t\t\t\t\thull_x.append(x)",
			"\t\t\t\t\tbreak",
			"\treturn hull_i, hull_x",
			"def max_query(x, m, c, hull_i, hull_x):",
			"\t\"\"\" Find maximum value at x in O(log n) time \"\"\"",
			"\ti = hull_i[bisect_left(hull_x, x)]",
			"\treturn m[i] * x + c[i]"
		],
		"description": "Convex hull trick for maximum queries"
	},
    "pnc": {
        "prefix": "pnc",
        "body": [
            "class Factorial:",
            "\tdef __init__(self, N, mod):",
            "\t\tN += 1",
            "\t\tself.mod = mod",
            "\t\tself.f = [1 for _ in range(N)]",
            "\t\tself.g = [1 for _ in range(N)]",
            "\t\tfor i in range(1, N):",
            "\t\t\tself.f[i] = self.f[i - 1] * i % self.mod",
            "\t\tself.g[-1] = pow(self.f[-1], mod - 2, mod)",
            "\t\tfor i in range(N - 2, -1, -1):",
            "\t\t\tself.g[i] = self.g[i + 1] * (i + 1) % self.mod",
            "\tdef fac(self, n):",
            "\t\treturn self.f[n]",
            "\tdef fac_inv(self, n):",
            "\t\treturn self.g[n]",
            "\tdef combi(self, n, m):",
            "\t\tif m == 0: return 1",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod",
            "\tdef permu(self, n, m):",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[n - m] % self.mod",
            "\tdef catalan(self, n):",
            "\t\treturn (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod",
            "\tdef inv(self, n):",
            "\t\treturn self.f[n-1] * self.g[n] % self.mod"
        ],
        "description": "Class for efficient computation of factorials, combinations, permutations, Catalan numbers, and modular inverses with precomputation."
    },
    "numtheory": {
        "prefix": "numtheory",
        "body": [
            "def sieve(n):",
            "\tprimes = []",
            "\tisp = [1] * (n+1)",
            "\tisp[0] = isp[1] = 0",
            "\tfor i in range(2,n+1):",
            "\t\tif isp[i]:",
            "\t\t\tprimes.append(i)",
            "\t\t\tfor j in range(i*i,n+1,i):",
            "\t\t\t\tisp[j] = 0",
            "\treturn primes",
            "",
            "def miller_is_prime(n):",
            "\t\"\"\"",
            "\t\tMiller-Rabin test - O(7 * log2n)",
            "\t\tHas 100% success rate for numbers less than 3e+9",
            "\t\tuse it in case of TC problem",
            "\t\"\"\"",
            "\tif n < 5 or n & 1 == 0 or n % 3 == 0:",
            "\t\treturn 2 <= n <= 3",
            "\ts = ((n - 1) & (1 - n)).bit_length() - 1",
            "\td = n >> s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:",
            "\t\t\tcontinue",
            "\t\tfor _ in range(s):",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == n - 1:",
            "\t\t\t\tbreak",
            "\t\telse:",
            "\t\t\treturn False",
            "\treturn True",
            "",
            "def is_prime(n):",
            "\tif n <= 1:",
            "\t\treturn False",
            "\tif n <= 3:",
            "\t\treturn True",
            "\tif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\ti = 5",
            "\twhile i * i <= n:",
            "\t\tif n % i == 0 or n % (i + 2) == 0:",
            "\t\t\treturn False",
            "\t\ti += 6",
            "\treturn True",
            "",
            "def all_factors(n):",
            "\t\"\"\"",
            "\treturns a sorted list of all distinct factors of n",
            "\t\"\"\"",
            "\tsmall, large = [], []",
            "\tfor i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):",
            "\t\tif not n % i:",
            "\t\t\tsmall.append(i)",
            "\t\t\tlarge.append(n // i)",
            "\tif small[-1] == large[-1]:",
            "\t\tlarge.pop()",
            "\tlarge.reverse()",
            "\tsmall.extend(large)",
            "\treturn small",
            ""
        ],
        "description": "numtheory implementation"
    },
    "SortedList": {
        "prefix": "bsortl",
        "body": [
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "T = TypeVar('T')",
            "class SortedList(Generic[T]):",
            "\tBUCKET_RATIO = 16",
            "\tSPLIT_RATIO = 24",
            "\tdef __init__(self, a: Iterable[T] = []) -> None:",
            "\t\ta = list(a)",
            "\t\tn = self.size = len(a)",
            "\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
            "\t\t\ta.sort()",
            "\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "\tdef __iter__(self) -> Iterator[T]:",
            "\t\tfor i in self.a:",
            "\t\t\tfor j in i: yield j",
            "\tdef __reversed__(self) -> Iterator[T]:",
            "\t\tfor i in reversed(self.a):",
            "\t\t\tfor j in reversed(i): yield j",
            "\tdef __eq__(self, other) -> bool:",
            "\t\treturn list(self) == list(other)",
            "\tdef __len__(self) -> int:",
            "\t\treturn self.size",
            "\tdef __repr__(self) -> str:",
            "\t\treturn \"SortedMultiset\" + str(self.a)",
            "\tdef __str__(self) -> str:",
            "\t\ts = str(list(self))",
            "\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
            "\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
            "\t\tfor i, a in enumerate(self.a):",
            "\t\t\tif x <= a[-1]: break",
            "\t\treturn (a, i, bisect_left(a, x))",
            "\tdef __contains__(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, _, i = self._position(x)",
            "\t\treturn i != len(a) and a[i] == x",
            "\tdef count(self, x: T) -> int:",
            "\t\treturn self.index_right(x) - self.index(x)",
            "\tdef insert(self, x: T) -> None:",
            "\t\tif self.size == 0:",
            "\t\t\tself.a = [[x]]",
            "\t\t\tself.size = 1",
            "\t\t\treturn",
            "\t\ta, b, i = self._position(x)",
            "\t\ta.insert(i, x)",
            "\t\tself.size += 1",
            "\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
            "\t\t\tmid = len(a) >> 1",
            "\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
            "\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
            "\t\tans = a.pop(i)",
            "\t\tself.size -= 1",
            "\t\tif not a: del self.a[b]",
            "\t\treturn ans",
            "\tdef remove(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, b, i = self._position(x)",
            "\t\tif i == len(a) or a[i] != x: return False",
            "\t\tself._pop(a, b, i)",
            "\t\treturn True",
            "\tdef lt(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] < x:",
            "\t\t\t\treturn a[bisect_left(a, x) - 1]",
            "\tdef le(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] <= x:",
            "\t\t\t\treturn a[bisect_right(a, x) - 1]",
            "\tdef gt(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn a[bisect_right(a, x)]",
            "\tdef ge(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn a[bisect_left(a, x)]",
            "\tdef __getitem__(self, i: int) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor a in reversed(self.a):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return a[i]",
            "\t\telse:",
            "\t\t\tfor a in self.a:",
            "\t\t\t\tif i < len(a): return a[i]",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef pop(self, i: int = -1) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor b, a in enumerate(reversed(self.a)):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
            "\t\telse:",
            "\t\t\tfor b, a in enumerate(self.a):",
            "\t\t\t\tif i < len(a): return self._pop(a, b, i)",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef index(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn ans + bisect_left(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef index_right(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn ans + bisect_right(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef find_closest(self, k: T) -> Optional[T]:",
            "\t\tif self.size == 0:",
            "\t\t\treturn None",
            "\t\tltk = self.le(k)",
            "\t\tgtk = self.ge(k)",
            "\t\tif ltk is None:",
            "\t\t\treturn gtk",
            "\t\tif gtk is None:",
            "\t\t\treturn ltk",
            "\t\tif abs(k-ltk)<=abs(k-gtk):",
            "\t\t\treturn ltk",
            "\t\telse:",
            "\t\t\treturn gtk"
        ],
        "description": "SortedList using buckets"
    },    
    "SegmentTree": {
        "prefix": "SegmentTree",
        "body": [
            "class SegmentTree:",
            "\t# all the operations in here are inclusive of l to r ",
            "\t# later on make it custom for each func like seg point ",
            "\tdef __init__(self, arr):",
            "\t\tself.arr = arr",
            "\t\tself.n = len(arr)",
            "\t\tself.tree = [0] * (4 * self.n)",
            "\t\tself.lazy = [0] * (4 * self.n)",
            "\t\tself.build_tree(1, 0, self.n - 1)",
            "\tdef build_tree(self, node, start, end):",
            "\t\tif start == end:",
            "\t\t\tself.tree[node] = self.arr[start]",
            "\t\telse:",
            "\t\t\tmid = (start + end) // 2",
            "\t\t\tself.build_tree(2 * node, start, mid)",
            "\t\t\tself.build_tree(2 * node + 1, mid + 1, end)",
            "\t\t\tself.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef propagate_lazy(self, node, start, end):",
            "\t\tif self.lazy[node] != 0:",
            "\t\t\tself.tree[node] += self.lazy[node]",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += self.lazy[node]",
            "\t\t\t\tself.lazy[2 * node + 1] += self.lazy[node]",
            "\t\t\tself.lazy[node] = 0",
            "\tdef update(self, node, start, end, l, r, value):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn",
            "\t\tif start >= l and end <= r:",
            "\t\t\tself.tree[node] += value",
            "\t\t\tif start != end:",
            "\t\t\t\tself.lazy[2 * node] += value",
            "\t\t\t\tself.lazy[2 * node + 1] += value",
            "\t\t\treturn",
            "\t\tmid = (start + end) // 2",
            "\t\tself.update(2 * node, start, mid, l, r, value)",
            "\t\tself.update(2 * node + 1, mid + 1, end, l, r, value)",
            "\t\tself.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])",
            "\tdef range_update(self, l, r, value):",
            "\t\tself.update(1, 0, self.n - 1, l, r, value)",
            "\tdef query(self, node, start, end, l, r):",
            "\t\tself.propagate_lazy(node, start, end)",
            "\t\tif start > r or end < l:",
            "\t\t\treturn float('inf')",
            "\t\tif start >= l and end <= r:",
            "\t\t\treturn self.tree[node]",
            "\t\tmid = (start + end) // 2",
            "\t\treturn min(self.query(2 * node, start, mid, l, r),",
            "\t\t           self.query(2 * node + 1, mid + 1, end, l, r))",
            "\tdef range_query(self, l, r):",
            "\t\treturn self.query(1, 0, self.n - 1, l, r)",
            "\tdef to_list(self):",
            "\t\tresult = []",
            "\t\tfor i in range(self.n):",
            "\t\t\tresult.append(self.range_query(i, i))",
            "\t\treturn result",
        ],
        "description": "Segment Tree implementation with lazy propagation"
    },
	"sortl": {
        "prefix": "fsortl",
        "body": [
            "class FenwickTree:",
            "\tdef __init__(self, x):",
            "\t\tbit = self.bit = list(x)",
            "\t\tsize = self.size = len(bit)",
            "\t\tfor i in range(size):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < size:",
            "\t\t\t\tbit[j] += bit[i]",
            "\tdef update(self, idx, x):",
            "\t\twhile idx < self.size:",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef __call__(self, end):",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1 ",
            "\t\treturn x",
            "\tdef find_kth(self, k):",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(self.size.bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < self.size and self.bit[right_idx] <= k:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1, k",
            "class SortedList:",
            "\tblock_size = 700",
            "\tdef __init__(self, iterable=()):",
            "\t\tself.macro = []",
            "\t\tself.micros = [[]]",
            "\t\tself.micro_size = [0]",
            "\t\tself.fenwick = FenwickTree([0])",
            "\t\tself.size = 0",
            "\t\tfor item in iterable:",
            "\t\t\tself.insert(item)",
            "\tdef insert(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\tj = bisect_right(self.micros[i], x)",
            "\t\tself.micros[i].insert(j, x)",
            "\t\tself.size += 1",
            "\t\tself.micro_size[i] += 1",
            "\t\tself.fenwick.update(i, 1)",
            "\t\tif len(self.micros[i]) >= self.block_size:",
            "\t\t\tself.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]",
            "\t\t\tself.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1",
            "\t\t\tself.fenwick = FenwickTree(self.micro_size)",
            "\t\t\tself.macro.insert(i, self.micros[i + 1][0])",
            "\tdef add(self, x):",
            "\t\tself.insert(x)",
            "\tdef pop(self, k=-1):",
            "\t\ti, j = self._find_kth(k)",
            "\t\tself.size -= 1",
            "\t\tself.micro_size[i] -= 1",
            "\t\tself.fenwick.update(i, -1)",
            "\t\treturn self.micros[i].pop(j)",
            "\tdef remove(self, N: int):",
            "\t\tidx = self.bisect_left(N)",
            "\t\tself.pop(idx)",
            "\tdef __getitem__(self, k):",
            "\t\ti, j = self._find_kth(k)",
            "\t\treturn self.micros[i][j]",
            "\tdef count(self, x):",
            "\t\treturn self.bisect_right(x) - self.bisect_left(x)",
            "\tdef __contains__(self, x):",
            "\t\treturn self.count(x) > 0",
            "\tdef bisect_left(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_left(self.micros[i], x)",
            "\tdef bisect_right(self, x):",
            "\t\ti = bisect_right(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_right(self.micros[i], x)",
            "\tdef _find_kth(self, k):",
            "\t\treturn self.fenwick.find_kth(k + self.size if k < 0 else k)",
            "\tdef __len__(self):",
            "\t\treturn self.size",
            "\tdef __iter__(self):",
            "\t\treturn (x for micro in self.micros for x in micro)",
            "\tdef __repr__(self):",
            "\t\treturn str(list(self))"
        ],
        "description": "sorted list using fenwick tree use for insertion,deletion,traversel in log(n)"
    },
    "bootstrap": {
        "prefix": "bootstrap",
        "body": [
            "from types import GeneratorType",
            "",
            "def bootstrap(f, stack=[]):",
            "\tdef wrappedfunc(*args, **kwargs):",
            "\t\tif stack:",
            "\t\t\treturn f(*args, **kwargs)",
            "\t\telse:",
            "\t\t\tto = f(*args, **kwargs)",
            "\t\t\twhile True:",
            "\t\t\t\tif type(to) is GeneratorType:",
            "\t\t\t\t\tstack.append(to)",
            "\t\t\t\t\tto = next(to)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.pop()",
            "\t\t\t\t\tif not stack:",
            "\t\t\t\t\t\tbreak",
            "\t\t\t\t\tto = stack[-1].send(to)",
            "\t\t\treturn to",
            "\treturn wrappedfunc",
            "",
            "# @bootstrap",
            "# put this just on top of recursion function to increase the recursion limit",
            "",
            "# rather than return now use yield and when function being called inside itself, use yield before the function name",
            "# example usage:",
            "# @bootstrap",
            "# def rec1(L,k,cur,count):",
            "# \tif count>=100000:",
            "# \t\tyield float('INF')",
            "# \tif cur+k+1>=len(L)-1:",
            "# \t\tyield L[cur]+2",
            "# \tif cur in d:",
            "# \t\tyield d[cur]",
            "# \tans = float('INF')",
            "# \tmini = float('INF')",
            "# \tfor i in range(k+1,0,-1):",
            "# \t\tif L[cur+i]<mini:",
            "# \t\t\tans = min(ans,1+L[cur]+(yield rec1(L,k,cur+i,count+1)))",
            "# \t\t\tmini = L[cur+i]",
            "# \td[cur] = ans",
            "# \tyield ans",
            "# the limit of recursion on cf is 10**6"
        ],
        "description": "Decorator to increase recursion limit using the bootstrap method with yield."
    },
    "sh": {
        "prefix": "sh",
        "body": [
            "def getSubHash(left,right,hash,power):",
            "\t#returns hash value of [left,right]",
            "\t#check for two diff hash,power to prevent collision",
            "\t#change MOD according to how many values you want ,",
            "\t#the more the value , lesser the collisiosn",
            "\tleft += 1",
            "\tright += 1",
            "\th1 = hash[right]",
            "\th2 = (hash[left - 1] * power[right - left + 1]) % MOD",
            "\treturn (h1 + MOD - h2) % MOD",
            "n = len(st)",
            "hash = [0] * (n + 1)",
            "# hash1 = [0] * (n + 1)",
            "power = [0] * (n + 1)",
            "# power1 = [0] * (n + 1)",
            "P = 131",
            "# P1 = 132",
            "power[0] = 1",
            "# power1[0] = 1",
            "for i in range(n):",
            "\tpower[i + 1] = (power[i] * P) % MOD",
            "\t# power1[i+1] = (power1[i] * P1) % MOD",
            "\thash[i + 1] = (hash[i] * P + ord(st[i])) % MOD",
            "\t# hash1[i + 1] = (hash1[i] * P1 + ord(st[i])) % MOD",
            "",
            "def z_function(S):",
            "\t# return: the Z array, where Z[i] = length of the longest common prefix of S[i:] and S",
            "\tn = len(S)",
            "\tZ = [0] * n",
            "\tl = r = 0",
            "\tfor i in range(1, n):",
            "\t\tz = Z[i - l]",
            "\t\tif i + z >= r:",
            "\t\t\tz = max(r - i, 0)",
            "\t\t\twhile i + z < n and S[z] == S[i + z]:",
            "\t\t\t\tz += 1",
            "\t\t\tl, r = i, i + z",
            "\t\tZ[i] = z",
            "\tZ[0] = n",
            "\treturn Z",
            ""
        ],
        "description": "sh implementation"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "class BIT:",
            "\t#Faster than segment tree so use if possbile",
            "\tdef __init__(self, x):",
            "\t\t\"\"\"transform list into BIT\"\"\"",
            "\t\tself.bit = x",
            "\t\tfor i in range(len(x)):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < len(x):",
            "\t\t\t\tx[j] += x[i]",
            "\tdef update(self, idx, x):",
            "\t\t\"\"\"updates bit[idx] += x\"\"\"",
            "\t\t#basically after that number greater greater than x will be added",
            "\t\twhile idx < len(self.bit):",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef query(self, end):",
            "\t\t\"\"\"calc sum(bit[:end])\"\"\"",
            "\t\t#gives sum of element before end",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1",
            "\t\treturn x",
            "\tdef findkth(self, k):",
            "\t\t\"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(len(self.bit).bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1"
        ]
    },
    "SegmentPoint": {
        "prefix": "SegmentPoint",
        "body": [
            "class SegmentTree:",
            "\t\"\"\"",
            "\t\tRemember to change the func content as well as the initializer to display the content",
            "\t\"\"\"",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\t# Change this function depending upon needs",
            "\t\treturn max(a, b)",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [0] * (2 * self.n)",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i] = data[i]",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1])",
            "\tdef update(self, pos, value):",
            "\t\t# Update the value at the leaf node",
            "\t\tpos += self.n",
            "\t\t# For updating",
            "\t\tself.tree[pos] = value",
            "\t\t# self.tree[pos] += value",
            "\t\t# If you want to add rather than update",
            "\t\twhile pos > 1:",
            "\t\t\tpos //= 2",
            "\t\t\tself.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1])",
            "\tdef query(self, left, right):",
            "\t\t# Query the maximum value in the range [left, right)",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\t# Change the initializer depending upon the self.func",
            "\t\tmax_val = float('-inf')",
            "\t\t##",
            "\t\twhile left < right:",
            "\t\t\tif left % 2:",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[left])",
            "\t\t\t\tleft += 1",
            "\t\t\tif right % 2:",
            "\t\t\t\tright -= 1",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[right])",
            "\t\t\tleft //= 2",
            "\t\t\tright //= 2",
            "\t\treturn max_val"
        ],
        "description": "Segment Tree implementation better for point updates and range queries"
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "class SparseTable:",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.table = [[0 for i in range(int((math.log(self.n, 2)+1)))] for j in range(self.n)]",
            "\t\tself.build(arr)",
            "\tdef build(self, arr):",
            "\t\tfor i in range(0, self.n):",
            "\t\t\tself.table[i][0] = arr[i]",
            "\t\tj = 1",
            "\t\twhile (1 << j) <= self.n:",
            "\t\t\ti = 0",
            "\t\t\twhile i <= self.n - (1 << j):",
            "\t\t\t\tself.table[i][j] = math.gcd(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])",
            "\t\t\t\ti += 1",
            "\t\t\tj += 1",
            "\tdef query(self, L, R):",
            "\t\tj = int(math.log2(R - L + 1))",
            "\t\treturn math.gcd(self.table[L][j], self.table[R - (1 << j) + 1][j])"
        ],
        "description": "Sparse Table"
    },
    "dpheq": {
        "prefix": "dpheq",
        "body": [
            "class DiophantineEquations:",
            "\t\"\"\"",
            "\t\tused for solving equations of the form a*x + b*y = c,",
            "\t\tsolnll takes the lower limit as well",
            "\t\"\"\"",
            "\tdef __init__(self):",
            "\t\tpass",
            "\tdef euclidean_gcd(self,a, b):",
            "\t\t\"\"\"",
            "\t\t\teuclidean gcd , returns x and y such that",
            "\t\t\ta*x + b*y = gcd(a,b)",
            "\t\t\"\"\"",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.euclidean_gcd(b, a % b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef soln(self,a,b,c,t=10**18,t1=10**18):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and 0<=m<=t and 0<=n<=t1",
            "\t\t\tdon't input t,t1 for any possible value",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c%g!=0:",
            "\t\t\treturn -1,-1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x*(c//g)",
            "\t\tn1 = y*(c//g)",
            "\t\tk1 = max(math.ceil(-k3*g/b),math.ceil((n1-t1)/(a/g)))",
            "\t\tkmaxi = min(math.floor((t-k3)/(b/g)), math.floor(n1/(a/g)))",
            "\t\tif k1<=kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3+k*(b//g)",
            "\t\t\tn = n1-k*(a//g)",
            "\t\t\treturn m, n",
            "\t\telse:",
            "\t\t\treturn -1,-1",
            "\tdef sollnll(self,a,b,c,t,t1,m_lower,n_lower):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and",
            "\t\t\tm_lower <= m <= t and n_lower <= n <= t1",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c % g != 0:",
            "\t\t\treturn -1, -1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x * (c // g)",
            "\t\tn1 = y * (c // g)",
            "\t\tk1 = max(math.ceil((m_lower - k3 * g) / b), math.ceil((n1 - t1) / (a / g)))",
            "\t\tkmaxi = min(math.floor((t - k3) / (b / g)), math.floor((n1 - n_lower) / (a / g)))",
            "\t\tif k1 <= kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3 + k * (b // g)",
            "\t\t\tn = n1 - k * (a // g)",
            "\t\t\tif m_lower <= m <= t and n_lower <= n <= t1:",
            "\t\t\t\treturn m, n",
            "\t\t\telse:",
            "\t\t\t\treturn -1,-1",
            "\t\telse:",
            "\t\t\treturn -1, -1",
            "Leq = DiophantineEquations()"
        ],
        "description": "dpheq implementation"
    }
}
